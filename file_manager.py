import shapes

class FileManager:
    def __init__(self, pygame, filename):
        self.pg = pygame
        self.filename = filename
        self.brackets = ""
        self.command_list = {"Blocks": ["continuousLine", "spline"]
                             , "Commands": ["start", "line"] 
                             , "Events" : ["wait", "end"]
                             , "Nodes": ["point", "bezier", "control"]}
        #self.snapshot = self.read()

    def set_filename(self, filename):
        if filename == "NOTHING":
            self.filename = "Auto"
        self.filename = filename

    def read(self):
        with open(self.filename, "r") as f:
            lines = f.readlines()

        started = False
        commands = []
        block = []
        for l in lines:
            if l.find("/*  "):
                started = True
            elif l.find("  */"):
                started = False
            
            if started:
                if l.find("EventCall") != -1 and l.capitalize().find("NOTHING") == -1:
                    message = l.split('"')[1]
                else:
                    message = "NOTHING"
                
                if l.find("// Block") != -1:
                    # continuousLine, spline
                    for b in self.command_list["Blocks"]:
                        if l.find(b) != -1:
                            block.append("continuousLine")
                elif l.find("// End Block") != -1:
                    commands.append(block)
                    block = []
                elif l.find("// Command") != -1:
                    # start, line
                    for c in self.command_list["Commands"]:
                        if l.find(c) != -1:
                            pt = shapes.Point(self.pg)
                            commands.append([c, pt, message])
                elif l.find("// Event"):
                    # wait, end
                    for e in self.command_list["Events"]:
                        if l.find(e) != -1:
                            commands.append([e, message])
                elif l.find("// Node") != -1:
                    # point, bezier, control
                    for n in self.command_list["Nodes"]:
                        if l.find("// Node") != -1:
                            commands.append([n, shapes.Point(), message])

    def write_code(self, path_list):
        with open("templateAuto.txt", "r") as f:
            template = f.readlines()

        with open("Auto.kt", 'w') as f:
            for l in template:
                f.write(l.replace("//REPLACE CLASS NAME//", self.filename.replace(".kt", "")))
                if "/* This is start of code generated by Hyperion Controller */" in l:
                    f.write(f"\t\t{path_list[0].get_start_command(False)}\n")
                    for path in path_list:
                        cmds = path.get_commands()
                        f.write("\t\tpath.segment(\n")
                        f.write("\t\t\tmutableListOf(\n")
                        for cmd in cmds:
                            event = f', EventCall("{cmd.event}")' if cmd.event != "NOTHING" else ""
                            use_error = f'.useError()' if cmd.is_error else ""
                            tolerance = f".setTolerance({cmd.rad/4})" if cmd.rad > 10 else ""
                            end_comma = "" if cmd.part_end else ","
                            f.write(f"\t\t\t\tPoint({cmd.pos[0]/4}, {cmd.pos[1]/4}, {round(cmd.get_rot(), 1)}{event}){use_error + tolerance + end_comma}\n")
                        f.write("\t\t\t)\n\t\t)\n")
                        wait = path.get_wait_event()
                        if wait != "NOTHING":
                            f.write(f'paths.wait({wait}, EventCall("{path.get_event()}"))')
                    f.write(f'\t\tpaths.end(EventCall("_"))\n')

    def write_text(self, path_list):
        self.filename = self.filename + ".txt" if self.filename.find(".") < 0 else self.filename[:self.filename.find(".")] + ".txt"
        with open(self.filename, "w") as f:
            f.write(path_list[0].get_start_command(True))
            for p in path_list:
                pts = p.get_commands()
                f.write(f"-segment {len(pts)}\n")
                for pt in pts:
                    error = "*" if pt.is_error else ""
                    tolerance = f"{pt.rad/4}" if pt.rad > 10 else "_"
                    event = "_" if pt.event == "NOTHING" else pt.event
                    f.write(f"{error}{pt.pos[0]/4},{pt.pos[1]/4},{round(pt.get_rot(), 1)} {tolerance} {event}\n")
                if p.get_wait_event() != "NOTHING":
                    f.write(f"-wait {p.get_wait_event()} {p.get_event()}\n")
            f.write("-end _")
                    

            

# if __name__ == '__main__':
#     manager = FileManager("Hello?", "Auto1.kt")
#     manager.write_code([['a', 'b', 'c', 'd'], ['e','f'], ['g', 'h']])
